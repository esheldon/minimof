#!/usr/bin/env python
from __future__ import print_function
import os
import time
import yaml
import numpy as np
import minimof
import ngmix
import sep

try:
    xrange
except:
    xrange=range

from argparse import ArgumentParser
parser=ArgumentParser()

parser.add_argument('config_file',help='config file name')
parser.add_argument('seed',type=int,help='seed for sim')
parser.add_argument('ntrial',type=int,help='number to simulate')

parser.add_argument('--save',
                    action='store_true',
                    help='save plots')

parser.add_argument('--show',
                    action='store_true',
                    help='show plots')
parser.add_argument('--show-corrected',
                    action='store_true',
                    help='show plots with neighbors subtracted')

parser.add_argument('--size',
                    type=int,
                    default=1000,
                    help='size of plot')
parser.add_argument('--corrected-size',
                    type=int,
                    default=1000,
                    help='size of corrected plot')



parser.add_argument('--trueguess',
                    action='store_true',
                    help='use true guess')
parser.add_argument('--pdfguess',
                    action='store_true',
                    help='use true guess')
parser.add_argument('--trueprior',
                    action='store_true',
                    help='use true priors')

def get_mof_prior(objects, jacobian, rng):
    """
    Note a single jacobian is being sent.  for multi-band this
    is the same as assuming they are all on the same coordinate system.
    
    assuming all images have the 
    prior for N objects.  The priors are the same for
    structural parameters, the only difference being the
    centers
    """

    nobj=len(objects)

    cen_priors=[]

    cen_sigma=jacobian.get_scale() # a pixel
    for i in xrange(nobj):
        row=objects['y'][i]-1
        col=objects['x'][i]-1

        v, u = jacobian(row, col)
        p=ngmix.priors.CenPrior(
            v,
            u,
            cen_sigma, cen_sigma,
            rng=rng,
        )
        cen_priors.append(p)

    g_prior=ngmix.priors.GPriorBA(
        0.2,
        rng=rng,
    )
    T_prior = ngmix.priors.TwoSidedErf(
        -1.0, 0.1, 1.0e6, 1.0e5,
        rng=rng,
    )

    fracdev_prior = ngmix.priors.Normal(0.0, 0.1, rng=rng)
    #fracdev_prior = ngmix.priors.Normal(0.0, 100, rng=rng)

    F_prior = ngmix.priors.TwoSidedErf(
        -100.0, 1.0, 1.0e9, 1.0e8,
        rng=rng,
    )

    return minimof.priors.PriorBDFSepMulti(
        cen_priors,
        g_prior,
        T_prior,
        fracdev_prior,
        F_prior,
    )

def get_guess(objects, jacobian, rng):

    scale=jacobian.get_scale()
    pos_range = scale*0.1

    npars_per=7
    nobj=len(objects)

    npars_tot = nobj*npars_per
    guess = np.zeros(npars_tot)

    for i in xrange(nobj):
        row=objects['y'][i]-1
        col=objects['x'][i]-1

        v, u = jacobian(row, col)

        T=scale**2 * (objects['x2'][i] + objects['y2'][i])
        flux=scale**2 * objects['flux'][i]

        beg=i*npars_per

        # always close guess for center
        guess[beg+0] = v + rng.uniform(low=-pos_range, high=pos_range)
        guess[beg+1] = u + rng.uniform(low=-pos_range, high=pos_range)

        # always arbitrary guess for shape
        guess[beg+2] = rng.uniform(low=-0.05, high=0.05)
        guess[beg+3] = rng.uniform(low=-0.05, high=0.05)

        guess[beg+4] = T*(1.0 + rng.uniform(low=-0.05, high=0.05))

        # arbitrary guess for fracdev
        guess[beg+5] = rng.uniform(low=0.4,high=0.6)

        guess[beg+6] = flux*(1.0 + rng.uniform(low=-0.05, high=0.05))

    return guess


def print_pars(nobj, npars_per, pars, front="    "):
    for i in range(nobj):
        beg=i*npars_per
        end=(i+1)*npars_per
        tpars=pars[beg:end]
        ngmix.print_pars(tpars, front=front)

def main():
    args=parser.parse_args()

    print("seed:",args.seed)
    with open(args.config_file) as fobj:
        config=yaml.load(fobj)

    pngbase=os.path.basename(args.config_file).replace('.yaml','')

    sim=minimof.moftest.Sim(config, args.seed)

    tm_sim=0.0
    tm_fit=0.0
    tm_extract=0.0
    nfail=0
    ntry=2

    for i in range(args.ntrial):
        print("-"*70)
        print("%d/%d" % (i+1, args.ntrial))

        this_tm_sim = time.time()
        sim.make_obs()
        this_tm_sim = time.time()-this_tm_sim

        this_tm_extract = time.time()
        objects, segmap = sep.extract(
            sim.image,
            1.5,
            #.5,
            err=sim['noise_sigma'],
            #minarea=2,
            deblend_cont=0.0001,
            segmentation_map=True,
        )
        this_tm_extract = time.time() - this_tm_extract 

        print("found",len(objects),"objects")
        nobj=len(objects)

        if nobj == 0:
            print("failed to find any objects")
            nfail += 1
            continue

        this_tm_fit = time.time()

        prior = get_mof_prior(
            objects,
            sim.obs.jacobian,
            sim.rng,
        )

        fitter=minimof.MOF(
            sim.obs,
            config['fit_model'],
            nobj,
            prior=prior,
        )

        for itry in range(ntry):
            guess = get_guess(objects, sim.obs.jacobian, sim.rng)
            fitter.go(guess)
            res=fitter.get_result()
            if res['flags']==0:
                break

        this_tm_fit = time.time()-this_tm_fit

        tm_fit += this_tm_fit
        tm_sim += this_tm_sim
        tm_extract += this_tm_extract

        print("this time fit:",this_tm_fit)

        if res['flags'] != 0:
            print("failed")
            nfail += 1

            if args.show:
                import images
                images.view(sim.obs.image)
                if input('hit a key (q to quit): ')=='q':
                    return
        else:

            print("nfev:",res['nfev'])
            npars_per=guess.size//nobj
            print_pars(nobj, npars_per, guess, front="guess: ")
            print_pars(nobj, npars_per, res['pars'], front="best_fit: ")

            model_image = fitter.make_image(0, 0)

            diff=model_image - sim.get_image()

            chi2 =  ( (diff**2).sum() / sim['noise_sigma']**2 )
            npars_tot=nobj*6
            dof = model_image.size - npars_tot
            chi2per = chi2/dof
            print("chi2per:",chi2per)

            if args.show or args.save or args.show_corrected:
                import images
                import biggles
                plt = biggles.Table(
                    2, 2,
                    aspect_ratio=1.0,
                    title=r'$\chi^2/dof: %.2f$' % chi2per,
                )
                plt[0,0] = images.view(sim.get_image(),
                                       title='image',
                                       show=False)
                plt[0,1] = images.view(model_image,
                                       title='model',
                                       show=False)
                plt[1,0] = images.view(sim.get_image()-model_image,
                                       title='image-model',
                                       show=False)

                if segmap is not None:
                    plt[1,1] = images.view(segmap, show=False, title='segmap')
                else:
                    plt[1,1] = images.view(sim.image0, show=False, title='truth')

                if args.show:
                    plt.show(
                        width=args.size,
                        height=args.size,
                    )

                if args.save:
                    pngname='%s-diff-%d-%06d.png' % (pngbase,args.seed,i)
                    print("writing:",pngname)
                    plt.write_img(args.size, args.size, pngname)


                nobj=fitter.get_nobj()
                if nobj > 1 and args.show_corrected:
                    import esutil as eu
                    grid=eu.plotting.Grid(nobj)
                    tab=biggles.Table(grid.nrow, grid.ncol)
                    arat=float(grid.nrow)/grid.ncol
                    tab.aspect_ratio=arat
                    for ishow in range(nobj):
                        row,col=grid.get_rowcol(ishow)

                        tobs=fitter.make_corrected_obs(ishow)
                        tab[row,col]=images.view(
                            tobs.image,
                            show=False,
                            title='%d' % ishow,
                        )

                    if args.show:
                        tab.show(
                            width=args.corrected_size,
                            height=args.corrected_size*arat,
                        )
                    if args.save:
                        pngname='%s-corr-%d-%06d.png' % (pngbase,args.seed,i)
                        print("writing:",pngname)
                        tab.write_img(
                            args.corrected_size,
                            args.corrected_size*arat,
                            pngname,
                        )



                if args.show or args.show_corrected:
                    if input('hit a key (q to quit): ')=='q':
                        return

    nuse=args.ntrial-nfail
    print("nfail: %d / %d %g" % (nfail, args.ntrial, float(nfail)/args.ntrial))
    print("time sim per trial:",tm_sim/nuse)
    print("time fit per trial:",tm_fit/nuse)
    print("time extract per trial:",tm_extract/nuse)


if __name__=="__main__":
    main()
